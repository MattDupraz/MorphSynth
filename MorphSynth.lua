class "MorphSynth"

require "MorphSynthWindow"
require "WaveFunctions"

require "utils"

----------------------------------------------------------------------------------------------------


function MorphSynth:__init ()

    self.instrument = renoise.song().selected_instrument

    self:load_parameters ()

    self.window = MorphSynthWindow (self)

    self.window:show_dialog ()

end


----------------------------------------------------------------------------------------------------


local default_waveform = { operator = "Sine", amplitude = 100, shape = 0, phase = 0, inverted = false, transpose = 0, finetune = 0, sample_and_hold = 0, ring_modulation = 0, frequency_modulation = 0 }



----------------------------------------------------------------------------------------------------


function MorphSynth:generate_samples ()

    -- Clear the samples previously generated by MorphSynth
    local i = 1
    while i <= #self.instrument.samples do
        if string.sub (self.instrument:sample(i).name, 1, 15) == "MorphSynth Note" then
            self.instrument:delete_sample_at (i)
        else
            i = i + 1
        end
    end

    self:save_parameters ()


    local first_note = self.first_note
    local last_note = self.last_note
    if first_note > last_note then
        first_note, last_note = last_note, first_note
    end

    local note = first_note
    local range_start, range_end

    repeat

        --~ in_progress_yield ()
        if note == first_note then
            range_start = 0
        else
            range_start = note
        end
        if note + self.keyzones_step > last_note then
            range_end = 119
        else
            range_end = note + self.keyzones_step - 1
        end

        for i = 1, 8 do
            if #self.voices[i].carrier.waveforms > 0 then
                self:generate_one_sample (note, range_start, range_end, i)
            end
        end

        note = note + self.keyzones_step

    until note > last_note

end


----------------------------------------------------------------------------------------------------

function MorphSynth:update_positions (section, period)

    local position = 1
    for j = 1, #section.waveforms do
        section.waveforms[j].position = position
        if section.durations[j].unit == "ms" then
            position = position + section.durations[j].value / 1000 * self.sample_rate
        elseif section.durations[j].unit == "s" then
            position = position + section.durations[j].value * self.sample_rate
        else
            position = position + section.durations[j].value * period
        end
    end

end


function MorphSynth:generate_one_sample (note, range_start, range_end, voice_index)

    local voice = self.voices[voice_index]

    local sample_rate = self.sample_rate

    local f = frequency_of_renoise_note (note + voice.transpose) ---TODO: boundary check
    local period = sample_rate / f

    self:update_positions (voice.carrier, period)
    self:update_positions (voice.ring_modulator, period)
    self:update_positions (voice.frequency_modulator, period)

    local nb_frames = math.floor (voice.carrier.waveforms[#voice.carrier.waveforms].position / period + 0.5) * period
    if nb_frames == 0 then
        nb_frames = period
    end

    local samples = {}
    for i = 1, nb_frames do
        samples[i] = 0
    end

    local ring_modulator_length = voice.ring_modulator.waveforms[#voice.ring_modulator.waveforms].position
    local frequency_modulator_length = voice.frequency_modulator.waveforms[#voice.frequency_modulator.waveforms].position

    WaveFunctions.initialize_random_seed (voice.seed * note * 127)

    local phase = 0
    local rm_phase = 0
    local fm_phase = 0
    for i = 1, #samples do

        -- Find the current segment for the carrier, ring modulator and FM modulator

        local index = 0
        repeat
            index = index + 1
        until index == #voice.carrier.waveforms
            or ((i >= voice.carrier.waveforms[index].position) and (i <= voice.carrier.waveforms[index + 1].position))

        --~ local full_cycles = math.floor (i / ring_modulator_length) * ring_modulator_length
        local rm_index = 0
        repeat
            rm_index = rm_index + 1
        until rm_index == #voice.ring_modulator.waveforms
            --~ or ((i - full_cycles >= voice.ring_modulator.waveforms[rm_index].position) and (i - full_cycles <= voice.ring_modulator.waveforms[rm_index + 1].position))
            or ((i >= voice.ring_modulator.waveforms[rm_index].position) and (i <= voice.ring_modulator.waveforms[rm_index + 1].position))

        --~ full_cycles = math.floor (i / frequency_modulator_length) * frequency_modulator_length
        local fm_index = 0
        repeat
            fm_index = fm_index + 1
        until fm_index == #voice.frequency_modulator.waveforms
            --~ or ((i - full_cycles >= voice.frequency_modulator.waveforms[fm_index].position) and (i - full_cycles <= voice.frequency_modulator.waveforms[fm_index + 1].position))
            or ((i >= voice.frequency_modulator.waveforms[fm_index].position) and (i <= voice.frequency_modulator.waveforms[fm_index + 1].position))

        --

        local ca1 = voice.carrier.waveforms[index]
        local segment_position = i - voice.carrier.waveforms[index].position
        local segment_length, scale, ca2, rm2, fm2
        if index < #voice.carrier.waveforms then
            segment_length = voice.carrier.waveforms[index + 1].position - voice.carrier.waveforms[index].position
            scale = voice.carrier.durations[index].scale
            ca2 = voice.carrier.waveforms[index + 1]
        else
            segment_length = #samples - voice.carrier.waveforms[index].position
            scale = 0
            ca2 = voice.carrier.waveforms[#voice.carrier.waveforms]
        end

        local rm1 = voice.ring_modulator.waveforms[rm_index]
        local rm_segment_position = i - voice.ring_modulator.waveforms[rm_index].position
        local rm_segment_length, rm_scale, rm2
        if rm_index < #voice.ring_modulator.waveforms then
            rm_segment_length = voice.ring_modulator.waveforms[rm_index + 1].position - voice.ring_modulator.waveforms[rm_index].position
            rm_scale = voice.ring_modulator.durations[rm_index].scale
            rm2 = voice.ring_modulator.waveforms[rm_index + 1]
        else
            rm_segment_length = #samples - voice.ring_modulator.waveforms[rm_index].position
            rm_scale = 0
            rm2 = voice.ring_modulator.waveforms[#voice.ring_modulator.waveforms]
        end

        local fm1 = voice.frequency_modulator.waveforms[fm_index]
        local fm_segment_position = i - voice.frequency_modulator.waveforms[fm_index].position
        local fm_segment_length, fm_scale, fm2
        if fm_index < #voice.frequency_modulator.waveforms then
            fm_segment_length = voice.frequency_modulator.waveforms[fm_index + 1].position - voice.frequency_modulator.waveforms[fm_index].position
            fm_scale = voice.frequency_modulator.durations[fm_index].scale
            fm2 = voice.frequency_modulator.waveforms[fm_index + 1]
        else
            fm_segment_length = #samples - voice.frequency_modulator.waveforms[fm_index].position
            fm_scale = 0
            fm2 = voice.frequency_modulator.waveforms[#voice.frequency_modulator.waveforms]
        end

        --

        local voice_note = note + voice.transpose

        local morph_position = self:morph_position (segment_position, segment_length, scale)
        local rm_morph_position = self:morph_position (rm_segment_position, rm_segment_length, rm_scale)
        local fm_morph_position = self:morph_position (fm_segment_position, fm_segment_length, fm_scale)

        local ring_modulation = (1 - rm_morph_position) * ca1.ring_modulation/100 + rm_morph_position * ca2.ring_modulation/100

        local sample_without_modulation = self:morph (morph_position, ca1, ca2, phase, period)
        samples[i] = (1 - ring_modulation) * sample_without_modulation
                + ring_modulation * sample_without_modulation * self:morph (rm_morph_position, rm1, rm2, rm_phase, period)

        local fm_frequency = self:frequency (fm_morph_position, fm1, fm2, voice_note)
        local deviation = self:morph (fm_morph_position, fm1, fm2, fm_phase, period) * fm_frequency

        local frequency_modulation = (1 - fm_morph_position) * ca1.frequency_modulation/100 + fm_morph_position * ca2.frequency_modulation/100
        phase = phase + self:frequency (morph_position, ca1, ca2, voice_note) / sample_rate + frequency_modulation * deviation / sample_rate

        rm_phase = rm_phase + self:frequency (fm_morph_position, rm1, rm2, voice_note) / sample_rate
        fm_phase = fm_phase + fm_frequency / sample_rate

    end

    -- Create and write the sample buffer

    local index = 1
    while index <= #self.instrument.samples
          and string.sub (self.instrument:sample(index).name, 1, 21) ~= "MorphSynth Parameters" do
        index = index + 1
    end
    local sample_index = #self.instrument.samples + 1
    if index <= #self.instrument.samples then
        sample_index = index
    end
    local sample = self.instrument:insert_sample_at (sample_index)

    local success = sample.sample_buffer:create_sample_data(self.sample_rate, self.bit_depth, 1, #samples)
    ---TODO: ?
    if not success then return end

    local sample_buffer = sample.sample_buffer
    sample_buffer:prepare_sample_data_changes ()
    for i = 1, #samples do
        sample_buffer:set_sample_data (1, i, samples[i])
    end
    sample_buffer:finalize_sample_data_changes ()

    if voice.loop_mode > 1 then
        sample.loop_mode = renoise.Sample.LOOP_MODE_FORWARD
        if voice.loop_mode == 2 then
            sample.loop_release = false
            voice.loop_to = #voice.carrier.waveforms
        else
            sample.loop_release = true
        end
        if voice.loop_from == 1 then
            sample.loop_start = 1
        elseif voice.loop_from >= #voice.carrier.waveforms then
            --~ sample.loop_start = math.floor (voice.waveforms[#voice.waveforms].position / period) * period - period
            sample.loop_start = #samples - period
        else
            sample.loop_start = math.floor (voice.carrier.waveforms[voice.loop_from].position / period) * period
        end
        local loop_to
        if voice.loop_to >= #voice.carrier.waveforms then
            --~ loop_to = math.floor (voice.waveforms[#voice.waveforms].position / period) * period
            loop_to = #samples
        else
            loop_to = math.floor (voice.carrier.waveforms[voice.loop_to].position / period + 1) * period
        end
        if loop_to > #samples then loop_to = #samples end
        sample.loop_end = loop_to
    else
        sample.loop_mode = renoise.Sample.LOOP_MODE_OFF
    end

    self.instrument:insert_sample_mapping (renoise.Instrument.LAYER_NOTE_ON, sample_index, note, {range_start, range_end})
    sample.name = "MorphSynth Note " .. name_of_renoise_note (note) .. " Voice " .. voice_index
    sample.volume = voice.volume
    sample.panning = (voice.panning + 50) / 100
    sample.fine_tune = voice.finetune
    if voice.new_note_action == "Continue" then
        sample.new_note_action = renoise.Sample.NEW_NOTE_ACTION_SUSTAIN
    elseif voice.new_note_action == "Note Off" then
        sample.new_note_action = renoise.Sample.NEW_NOTE_ACTION_NOTE_OFF
    else
        sample.new_note_action = renoise.Sample.NEW_NOTE_ACTION_NOTE_CUT
    end
    sample.autofade = voice.autofade

end


----------------------------------------------------------------------------------------------------


function MorphSynth:morph_position (position, length, scale)

    local p = position / length

    -- The "morphing" can be linear, logarithmic or exponential
    if scale > 0 then
        scale = 10 ^ (scale / 50)
        p = math.log ((scale - 1) * p + 1) / math.log (scale)
    elseif scale < 0 then
        scale = 10 ^ (-scale / 50)
        p = (scale ^ p - 1) / (scale - 1)
    end

    return p

end


----------------------------------------------------------------------------------------------------


function MorphSynth:morph (p, w1, w2, phase, period)

    local sample

    local shape = ((1- p) * w1.shape + p * w2.shape) / 100
    local amplitude = ((1- p) * w1.amplitude + p * w2.amplitude) / 100
    local phase_offset = ((1- p) * w1.phase + p * w2.phase) / 360
    phase = (phase + phase_offset) % 1

    local sample_and_hold = (1 - p) * w1.sample_and_hold + p * w2.sample_and_hold
    if sample_and_hold >= 1 then
        local l = period / sample_and_hold
        if l < 4 then l = 4 end
        phase = math.floor(phase * l) / l
    end

    local func1 = WaveFunctions[w1.operator]
    local inv1 = 1
    if w1.inverted then inv1 = -1 end
    local func2 = WaveFunctions[w2.operator]
    local inv2 = 1
    if w2.inverted then inv2 = -1 end
    sample = amplitude * ((1 - p) * inv1 * func1 (phase, shape) + p * inv2 * func2 (phase, shape))

    return sample

end


----------------------------------------------------------------------------------------------------


function MorphSynth:frequency (p, w1, w2, voice_note)

    local note1 = voice_note + w1.transpose + w1.finetune/100
    local note2 = voice_note + w2.transpose + w2.finetune/100
    local morphed_note
    if note1 ~= note2 then
        morphed_note = (1 - p) * note1 + p * note2
    else
        morphed_note = note1
    end
    return frequency_of_renoise_note (morphed_note)

end



----------------------------------------------------------------------------------------------------


function MorphSynth:initialize_parameters ()

    self.version = 2

    self.sample_rate = 44100
    self.bit_depth = 16

    self.first_note = 48
    self.last_note = 48
    self.keyzones_step = 3

    self.voices = { {}, {}, {}, {}, {}, {}, {}, {}, }

    local default_duration = { value = 0, unit = "ms", scale = 0 }

    for i = 1, 8 do

        self.voices[i].volume = 1
        self.voices[i].panning = 0
        self.voices[i].transpose = 0
        self.voices[i].finetune = 0
        self.voices[i].seed = 0
        self.voices[i].new_note_action = "Cut"
        self.voices[i].autofade = false
        self.voices[i].envelopes = true

        self.voices[i].loop_mode = 2
        self.voices[i].loop_from = 1
        self.voices[i].loop_to = 1

        self.voices[i].carrier = { durations={}, waveforms={} }
        self.voices[i].ring_modulator = { durations={default_duration}, waveforms={default_waveform} }
        self.voices[i].frequency_modulator = { durations={default_duration}, waveforms={default_waveform} }

    end

    self.voices[1].carrier.durations = { default_duration }
    self.voices[1].carrier.waveforms = { default_waveform }

end


----------------------------------------------------------------------------------------------------


function MorphSynth:save_parameters ()

    local index = 1
    if
        #self.instrument.samples == 1
        and self.instrument:sample(1).name == ""
        and not self.instrument:sample(1).sample_buffer.has_sample_data
    then
        self.instrument.name = "New MorphSynth Instrument"
        --TODO: should check if there is one?
        self.instrument:delete_sample_mapping_at (renoise.Instrument.LAYER_NOTE_ON, 1)
    else
        while index <= #self.instrument.samples
              and string.sub (self.instrument:sample(index).name, 1, 21) ~= "MorphSynth Parameters" do
            index = index + 1
        end
        if index > #self.instrument.samples then
            self.instrument:insert_sample_at (index)
        end
    end

    self.instrument.samples[index].sample_buffer:create_sample_data (44100, 16, 1, 1)

    local name = "MorphSynth Parameters {"

    name = name .. "version=" .. self.version .. ","

    name = name .. "sample_rate=" .. self.sample_rate .. ","
    name = name .. "bit_depth=" .. self.bit_depth .. ","

    name = name .. "first_note=" .. self.first_note .. ","
    name = name .. "last_note=" .. self.last_note .. ","
    name = name .. "keyzones_step=" .. self.keyzones_step .. ","

    name = name .. "voices={"
    for j = 1, 8 do

        local voice = self.voices[j]

        name = name .. "{"

        name = name .. "volume=" .. voice.volume .. ","
        name = name .. "panning=" .. voice.panning .. ","
        name = name .. "transpose=" .. voice.transpose .. ","
        name = name .. "finetune=" .. voice.finetune .. ","
        name = name .. "seed=" .. voice.seed .. ","
        name = name .. 'new_note_action="' .. voice.new_note_action .. '",'
        if voice.autofade then
            name = name .. "autofade=true,"
        else
            name = name .. "autofade=false,"
        end
        if voice.envelopes then
            name = name .. "envelopes=true,"
        else
            name = name .. "envelopes=false,"
        end

        name = name .. "loop_mode=" .. voice.loop_mode .. ","
        name = name .. "loop_from=" .. voice.loop_from .. ","
        name = name .. "loop_to=" .. voice.loop_to .. ","

        name = name .. "carrier={"

        name = name .. "durations={"
        for i = 1, #voice.carrier.durations do
            name = name .. "{"
            name = name .. "value=" .. voice.carrier.durations[i].value .. ","
            name = name .. 'unit="' .. voice.carrier.durations[i].unit .. '",'
            name = name .. "scale=" .. voice.carrier.durations[i].scale
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "waveforms={"
        for i = 1, #voice.carrier.waveforms do
            name = name .. "{"
            name = name .. 'operator="' .. voice.carrier.waveforms[i].operator .. '",'
            name = name .. "amplitude=" .. voice.carrier.waveforms[i].amplitude .. ","
            name = name .. "shape=" .. voice.carrier.waveforms[i].shape .. ","
            name = name .. "phase=" .. voice.carrier.waveforms[i].phase .. ","
            if voice.carrier.waveforms[i].inverted then
                name = name .. "inverted=true,"
            else
                name = name .. "inverted=false,"
            end
            name = name .. "transpose=" .. voice.carrier.waveforms[i].transpose .. ","
            name = name .. "finetune=" .. voice.carrier.waveforms[i].finetune .. ","
            name = name .. "sample_and_hold=" .. voice.carrier.waveforms[i].sample_and_hold .. ","
            name = name .. "ring_modulation=" .. voice.carrier.waveforms[i].ring_modulation .. ","
            name = name .. "frequency_modulation=" .. voice.carrier.waveforms[i].frequency_modulation .. ","
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "}," -- carrier

        name = name .. "ring_modulator={"

        name = name .. "durations={"
        for i = 1, #voice.ring_modulator.durations do
            name = name .. "{"
            name = name .. "value=" .. voice.ring_modulator.durations[i].value .. ","
            name = name .. 'unit="' .. voice.ring_modulator.durations[i].unit .. '",'
            name = name .. "scale=" .. voice.ring_modulator.durations[i].scale
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "waveforms={"
        for i = 1, #voice.ring_modulator.waveforms do
            name = name .. "{"
            name = name .. 'operator="' .. voice.ring_modulator.waveforms[i].operator .. '",'
            name = name .. "amplitude=" .. voice.ring_modulator.waveforms[i].amplitude .. ","
            name = name .. "shape=" .. voice.ring_modulator.waveforms[i].shape .. ","
            name = name .. "phase=" .. voice.ring_modulator.waveforms[i].phase .. ","
            if voice.ring_modulator.waveforms[i].inverted then
                name = name .. "inverted=true,"
            else
                name = name .. "inverted=false,"
            end
            name = name .. "transpose=" .. voice.ring_modulator.waveforms[i].transpose .. ","
            name = name .. "finetune=" .. voice.ring_modulator.waveforms[i].finetune .. ","
            name = name .. "sample_and_hold=" .. voice.ring_modulator.waveforms[i].sample_and_hold .. ","
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "}," -- ring_modulator

        name = name .. "frequency_modulator={"

        name = name .. "durations={"
        for i = 1, #voice.frequency_modulator.durations do
            name = name .. "{"
            name = name .. "value=" .. voice.frequency_modulator.durations[i].value .. ","
            name = name .. 'unit="' .. voice.frequency_modulator.durations[i].unit .. '",'
            name = name .. "scale=" .. voice.frequency_modulator.durations[i].scale
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "waveforms={"
        for i = 1, #voice.frequency_modulator.waveforms do
            name = name .. "{"
            name = name .. 'operator="' .. voice.frequency_modulator.waveforms[i].operator .. '",'
            name = name .. "amplitude=" .. voice.frequency_modulator.waveforms[i].amplitude .. ","
            name = name .. "shape=" .. voice.frequency_modulator.waveforms[i].shape .. ","
            name = name .. "phase=" .. voice.frequency_modulator.waveforms[i].phase .. ","
            if voice.frequency_modulator.waveforms[i].inverted then
                name = name .. "inverted=true,"
            else
                name = name .. "inverted=false,"
            end
            name = name .. "transpose=" .. voice.frequency_modulator.waveforms[i].transpose .. ","
            name = name .. "finetune=" .. voice.frequency_modulator.waveforms[i].finetune .. ","
            name = name .. "sample_and_hold=" .. voice.frequency_modulator.waveforms[i].sample_and_hold .. ","
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "}," -- frequency_modulator

        name = name .. "},"

    end
    name = name .. "},"

    self.instrument.samples[index].name = name .. "}"

end


----------------------------------------------------------------------------------------------------


function MorphSynth:load_parameters ()

    local index = 1
    while index <= #self.instrument.samples
          and string.sub (self.instrument:sample(index).name, 1, 21) ~= "MorphSynth Parameters" do
        index = index + 1
    end

    if index > #self.instrument.samples then
        self:initialize_parameters ()
        return
    end

    local name = self.instrument.samples[index].name

    local data_string = "return" .. string.sub (name, 22)

    local f = loadstring (data_string)

    local data = f ()

    self.version = data.version

    self.sample_rate = data.sample_rate
    self.bit_depth = data.bit_depth

    self.first_note = data.first_note
    self.last_note = data.last_note
    self.keyzones_step = data.keyzones_step
--~
    --~ self.volume = data.volume
    --~ self.panning = data.panning
    --~ self.transpose = data.transpose
    --~ self.finetune = data.finetune
    --~ self.seed = data.seed
    --~ self.new_note_action = data.new_note_action
    --~ self.autofade = data.autofade
    --~ self.envelopes = data.envelopes
--~
    --~ self.loop_mode = data.loop_mode
    --~ self.loop_from = data.loop_from
    --~ self.loop_to = data.loop_to

    self.voices = data.voices

end
